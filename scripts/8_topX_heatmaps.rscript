#! /usr/bin/env Rscript

# Will not generate heatmaps for cluster of size > max_cluster_size
# max_cluster_size <- 2000

# # General setup - calling libraries, etc. --------------------------------------------------------------
msg <- file("logs/8_heatmaps.txt", open="wt")
sink(msg, type="message")

libs <- c("optparse", "magrittr", "fossil", "tidyr", "plyr", "dplyr", 
          "readr", "heatmap3", "testit", "tibble", "reshape2", "RColorBrewer", 
          "gplots", "data.table", "R6", "ggplot2")
# library(beepr)
y <- suppressWarnings(
  suppressPackageStartupMessages(
    lapply(libs, require, character.only = TRUE)))

cat(paste0("\n||", paste0(rep("-", 28), collapse = ""), " (8/8) Starting heatmap generation ", 
           paste0(rep("-", 28), collapse = ""), "||\n"))

# This section collects user-specified inputs ----------------------------------------------------------
source("scripts/arguments.R")

cluster_mapping <- readRDS(arg$tpn)

# Reading in required functions, checking for pre-processed results (e.g. distances) -------------------
source("scripts/Misc/plotting_functions.R")

invl <- params$int_type[2]
basedir <- file.path("results", invl)
dir.create(file.path(basedir,"heatmaps"), showWarnings = FALSE, recursive = TRUE)
dir.create(file.path(basedir,"heatmaps", "clustering"), showWarnings = FALSE, recursive = TRUE)
dir.create(file.path(basedir,"densities"), showWarnings = FALSE, recursive = TRUE)
dir.create(file.path(basedir,"frequencies"), showWarnings = FALSE, recursive = TRUE)

# The number of clusters to generate heatmaps for:
# Will collect the largest ones, looking at the full data set (last time point,
# when all strains are present). Set in "Generate heatmaps" line in form_inputs.txt file
num_cl <- as.integer(params$numcl[2])

if (num_cl == 0) {
  cat(paste0("No data generated for heatmaps; user input gave ", 
             "'Generate heatmaps for top 0 largest clusters'"))
}else {
  # the column to use for clustering information
  cluster_by <- params$clustby[2]
  # color scheme - should be user inputs
  heatcolor <- colorRampPalette(c(params$lowcol[2],params$midcol[2],params$highcol[2]))(512)
  col_dir <- c(params$lowcol[2], params$highcol[2]) #c("Low similarity", "High similarity")
  
  clustering_fname <- file.path("results", invl, "cluster_labs.txt")
  
  assert("7a_topX_distances.R was run beforehand", file.exists(clustering_fname))
  clusters <- read_tsv(clustering_fname) %>% arrange(TP2_cluster_size)
  
  metadata <- suppressMessages(read_tsv(arg$metadata)) %>% processedStrains()
  cfile_path <- file.path("results", invl, "epitables")
  cfiles <- list.files(path = cfile_path, full.names = TRUE)
  
  for (i in 1:nrow(clusters)) {
  
    cname <- paste0(clusters$chr[i], "-", clusters$old_cl[i])
    x1 <- file.path(cfile_path, paste0(cname, ".Rds"))
    assert(paste0("Cluster ", cname, "found in results/", invl, "/epitables"), x1 %in% cfiles)
    
    epitable <- readRDS(x1) %>% mutate(Temp_Geo.Dist = (Temp.Dist + Geog.Dist)/2)
    
    # euclidean distances, later using single linkage clustering (these should be user inputs)
    # Processing epitables into temporal distance matrices, one for each cluster
    temp_mat <- prepEpiMatrix(epitable, "Temp.Dist")
    ordered_by_date <- metadata$strain_data %>% select(Strain, Date) %>% arrange(Date) %>%
      filter(Strain %in% rownames(temp_mat)) %>% pull(Strain)
    temp_mat <- temp_mat[ordered_by_date,ordered_by_date]
    
    # Processing epitables into geographical distance matrices, one for each cluster
    geo_mat <- prepEpiMatrix(epitable, "Geog.Dist")
    geo_mat <- geo_mat[ordered_by_date,ordered_by_date]
    
    # Processing epitables into geographical distance matrices, one for each cluster
    temp_geo_mat <- prepEpiMatrix(epitable, "Temp_Geo.Dist")
    temp_geo_mat <- temp_geo_mat[ordered_by_date,ordered_by_date]
    
    # Saving the temporal and geographical distance matrices as heatmaps
    outputDetails(paste0("(", i, "/", nrow(clusters), ") Saving plots for cluster ", clusters$chr[i], " (", 
                         clusters$old_cl[i], ", size ", clusters$TP2_cluster_size[i], 
                         ") - after last TP ..."), newcat = TRUE)
    
    if (clusters$TP2_cluster_size[i] > as.double(params$mincl[2])) {
      
      original_cluster <- cluster_mapping$pango_clusters %>% 
        left_join(clusters[i,], ., by = c("old_h", "old_cl", "new_h", "new_cl")) %>% 
        pull(T0.original) %>% unique()
      assert("Only one T0.original label for this cluster", length(original_cluster) == 1)
      
      cl_id <- paste0(clusters$chr[i], "-", original_cluster)
      
      clustering_mat <- switch(cluster_by, "temp" = temp_mat, "geo" = geo_mat, "temp_geo" = temp_geo_mat)
      hc_choice <- hclust(as.dist(clustering_mat), method="single")
      
      outputDetails(paste0("   Generating heatmap, density plot, and frequency histogram for: "), newcat = TRUE)
  
      # TEMPORAL ---------------------------------------------------------------------------------------
      outputDetails(paste0("      - temporal data"), newcat = TRUE)
      tname <- paste0(cl_id, "-temp.png")
      
      png(file.path(basedir, "heatmaps", tname))
      heatmapPlot(temp_mat, heatcolor, hc_choice, col_dir); dev.off()
      png(file.path(basedir, "densities", tname))
      densityPlot(temp_mat, "Temporal"); dev.off()
      p_t <- frequencyPlot(temp_mat, "Temporal")
      ggsave(file.path(basedir, "frequencies", tname), plot = p_t)
      
      # GEOGRAPHICAL -----------------------------------------------------------------------------------
      outputDetails(paste0("      - geographical data"), newcat = TRUE)
      gname <- paste0(cl_id, "-geo.png")
      
      png(file.path(basedir, "heatmaps", gname))
      heatmapPlot(geo_mat, heatcolor, hc_choice, col_dir); dev.off()
      png(file.path(basedir, "densities", gname))
      densityPlot(geo_mat, "Geographical"); dev.off()
      p_g <- frequencyPlot(geo_mat, "Geographical")
      ggsave(file.path(basedir, "frequencies", gname), plot = p_g)
      
      
      # TEMP AND GEO -----------------------------------------------------------------------------------
      outputDetails(paste0("      - (temp+geo)/2 data"), newcat = TRUE)
      tgname <- paste0(cl_id, "-tempgeo.png")
      
      png(file.path(basedir, "heatmaps", tgname))
      heatmapPlot(temp_geo_mat, heatcolor, hc_choice, col_dir); dev.off()
      png(file.path(basedir, "densities", tgname))
      densityPlot(temp_geo_mat, "Temp and geo"); dev.off()
      p_tg <- frequencyPlot(temp_geo_mat, "Temp and geo")
      ggsave(file.path(basedir, "frequencies", tgname), plot = p_tg)
      
      
      # Save clustering separately ---------------------------------------------------------------------
      # Used this method (https://stackoverflow.com/questions/18354501/how-to-get-member-of-clusters-from-rs-hclust-heatmap-2)
      # to extract the clustering from the heatmaps
      
      user_clustering <- cutree(hc_choice, 1:dim(clustering_mat)[1])
      file.path(basedir, "heatmaps", "clustering", paste0(cl_id, ".Rds")) %>% saveRDS(user_clustering, .)
      
    }else {
      outputDetails(paste0("TP2 cluster ", clusters$chr[i], " has only one strain, no heatmap generated\n"))
    }
  }
  
  paste0("\nHeatmaps saved to ", file.path("results", invl, "heatmaps")) %>% outputDetails(., TRUE)
  paste0("\nEpitables saved to ", file.path("results", invl, "epitables")) %>% outputDetails(., TRUE)
  paste0("\nClustering done in the heatmaps saved to ", file.path("results", invl, "heatmaps", "clustering")) %>% 
    outputDetails(., TRUE)
}

cat(paste0("\n||", paste0(rep("-", 31), collapse = ""), " Completed heatmap generation ", 
           paste0(rep("-", 30), collapse = ""), "||\n"))
