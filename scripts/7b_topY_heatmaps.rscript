#! /usr/bin/env Rscript

# Will not generate heatmaps for cluster of size > max_cluster_size
# max_cluster_size <- 2000

# # General setup - calling libraries, etc. --------------------------------------------------------------
msg <- file("logs/heatmaps.txt", open="wt")
sink(msg, type="message")

libs <- c("optparse", "magrittr", "fossil", "tidyr", "plyr", "dplyr", "readr", "heatmap3",
          "testit", "tibble", "reshape2", "RColorBrewer", "gplots", "data.table", "R6")
y <- suppressWarnings(
  suppressPackageStartupMessages(
    lapply(libs, require, character.only = TRUE)))

cat(paste0("\n||", paste0(rep("-", 31), collapse = ""), " Starting heatmap generation ", 
           paste0(rep("-", 31), collapse = ""), "||\n"))

# This section collects user-specified inputs ----------------------------------------------------------
source("scripts/arguments.R")

# Reading in required functions, checking for pre-processed results (e.g. distances) -------------------
source("scripts/Misc/plotting_functions.R")

basedir <- file.path("results", params$int_type[2])
dir.create(file.path(basedir,"heatmaps"), showWarnings = FALSE, recursive = TRUE)
dir.create(file.path(basedir,"heatmaps", "clustering"), showWarnings = FALSE, recursive = TRUE)
dir.create(file.path(basedir,"densities"), showWarnings = FALSE, recursive = TRUE)
dir.create(file.path(basedir,"frequencies"), showWarnings = FALSE, recursive = TRUE)

# The number of clusters to generate heatmaps for:
# Will collect the largest ones, looking at the full data set (last time point,
# when all strains are present). Set in "Generate heatmaps" line in form_inputs.txt file
num_cl <- as.integer(params$numcl[2])

if (num_cl == 0) {
  cat(paste0("No data generated for heatmaps; user input gave ", 
             "'Generate heatmaps for top 0 largest clusters'"))
}else {
  # the column to use for clustering information
  cluster_by <- params$clustby[2]
  # color scheme - should be user inputs
  heatcolor <- colorRampPalette(c(params$lowcol[2],params$midcol[2],params$highcol[2]))(512)
  col_dir <- c(params$lowcol[2], params$highcol[2]) #c("Low similarity", "High similarity")
  
  
  # clustering_fname <- file.path("intermediate_data", params$int_type[2], "cluster_labs.Rds")
  clustering_fname <- file.path("results", params$int_type[2], "cluster_labs.Rds")
  
  assert("7a_topX_distances.R was run beforehand", file.exists(clustering_fname))
  clusters <- readRDS(clustering_fname) %>% arrange(TP2_cluster_size)
  
  metadata <- suppressMessages(read_tsv(arg$metadata)) %>% processedStrains()
  
  for (i in 1:nrow(clusters)) {
    
    epitable <- file.path("results", params$int_type[2], "epitables", 
                          paste0(clusters$chr[i], "-", clusters$original_cl[i], ".Rds")) %>% 
      readRDS() %>% mutate(Temp_Geo.Dist = (Temp.Dist + Geog.Dist)/2)
    
    # euclidean distances, later using single linkage clustering (these should be user inputs)
    # Processing epitables into temporal distance matrices, one for each cluster
    temp_mat <- prepEpiMatrix(epitable, "Temp.Dist")
    ordered_by_date <- metadata$strain_data %>% select(Strain, Date) %>% arrange(Date) %>%
      filter(Strain %in% rownames(temp_mat)) %>% pull(Strain)
    temp_mat <- temp_mat[ordered_by_date,ordered_by_date]
    
    # Processing epitables into geographical distance matrices, one for each cluster
    geo_mat <- prepEpiMatrix(epitable, "Geog.Dist")
    geo_mat <- geo_mat[ordered_by_date,ordered_by_date]
    
    # Processing epitables into geographical distance matrices, one for each cluster
    temp_geo_mat <- prepEpiMatrix(epitable, "Temp_Geo.Dist")
    temp_geo_mat <- temp_geo_mat[ordered_by_date,ordered_by_date]
    
    # Saving the temporal and geographical distance matrices as heatmaps
    outputDetails(paste0("(", i, "/", nrow(clusters), ") Saving plots for cluster ", clusters$chr[i], " (", 
                         clusters$original_cl[i], ", size ", clusters$TP2_cluster_size[i], 
                         ") - after last TP ..."), newcat = TRUE)
    
    if (clusters$TP2_cluster_size[i] > 1) {
      cl_id <- paste0(clusters$chr[i], "-", clusters$original_cl[i])
      
      clustering_mat <- switch(cluster_by, "temp" = temp_mat, "geo" = geo_mat, "temp_geo" = temp_geo_mat)
      hc_choice <- hclust(as.dist(clustering_mat), method="single")
      
      outputDetails(paste0("   Generating heatmap, density plot, and frequency histogram for: "), newcat = TRUE)
      # TEMPORAL ---------------------------------------------------------------------------------------
      outputDetails(paste0("      - temporal data"), newcat = TRUE)
      tname <- paste0(cl_id, "-temp.png")
      
      
      png(file.path(basedir, "heatmaps", tname))
      heatmapPlot(temp_mat, heatcolor, hc_choice, col_dir); dev.off()
      png(file.path(basedir, "densities", tname))
      densityPlot(temp_mat, "Temporal"); dev.off()
      png(file.path(basedir, "frequencies", tname))
      frequencyPlot(temp_mat, "Temporal"); dev.off()
      
      # GEOGRAPHICAL -----------------------------------------------------------------------------------
      outputDetails(paste0("      - geographical data"), newcat = TRUE)
      gname <- paste0(cl_id, "-geo.png")
      
      png(file.path(basedir, "heatmaps", gname))
      heatmapPlot(geo_mat, heatcolor, hc_choice, col_dir); dev.off()
      png(file.path(basedir, "densities", gname))
      densityPlot(geo_mat, "Geographical"); dev.off()
      png(file.path(basedir, "frequencies", gname))
      frequencyPlot(geo_mat, "Geographical"); dev.off()
      
      
      # TEMP AND GEO -----------------------------------------------------------------------------------
      outputDetails(paste0("      - (temp+geo)/2 data"), newcat = TRUE)
      tgname <- paste0(cl_id, "-tempgeo.png")
      
      png(file.path(basedir, "heatmaps", tgname))
      heatmapPlot(temp_geo_mat, heatcolor, hc_choice, col_dir); dev.off()
      png(file.path(basedir, "densities", tgname))
      densityPlot(temp_geo_mat, "Temp and geo"); dev.off()
      png(file.path(basedir, "frequencies", tgname))
      frequencyPlot(temp_geo_mat, "Temp and geo"); dev.off()
      
      
      # Save clustering separately ---------------------------------------------------------------------
      # Used this method (https://stackoverflow.com/questions/18354501/how-to-get-member-of-clusters-from-rs-hclust-heatmap-2)
      # to extract the clustering from the heatmaps
      
      user_clustering <- cutree(hc_choice, 1:dim(clustering_mat)[1])
      file.path(basedir, "heatmaps", "clustering", paste0(cl_id, ".Rds")) %>% saveRDS(user_clustering, .)
      
    }else {
      outputDetails(paste0("TP2 cluster ", clusters$chr[i], " has only one strain, no heatmap generated"))
    }
  }
  
  paste0("\nHeatmaps saved to ", file.path("results", params$int_type[2], "heatmaps")) %>% outputDetails(., TRUE)
  paste0("\nEpitables saved to ", file.path("results", params$int_type[2], "epitables")) %>% outputDetails(., TRUE)
  paste0("\nClustering done in the heatmaps saved to ", file.path("results", params$int_type[2], "heatmaps", "clustering")) %>% 
    outputDetails(., TRUE)
}

cat(paste0("\n||", paste0(rep("-", 31), collapse = ""), " Completed heatmap generation ", 
           paste0(rep("-", 30), collapse = ""), "||\n"))
